# Why hyper

hyper is a service framework -- a collection of core application services wrapped in a common API.

Instead of tightly connecting your application business logic to the cloud services and products your app depends on, hyper enables you to loosely couple these cloud services, giving your application clear separation and future extensibility and scalability.

hyper takes a different approach than the legacy service management architectures. This approach improves maintainability and drastically decreases unintended technical debt.

Read more about [Why we built hyper](https://blog.hyper.io/why-start-hyper/)

## The Scaling Dilemma

Once organizations achieve product-market fit, their application often requires restructuring to accommodate growth aka “scale”.

Because Cloud providers are increasingly complex, increasingly specialized, and sticky by design, the decision “to scale” results in drastic upfront costs and ever-increasing recurring costs to iterate.

Organizations sputter out attempting to achieve scale, due to these costs.

### hyper Upgrades Software for Growth

Using the hyper Service Framework places a context-bound API on top of the services tier, and encourage business logic encapsulation _away_ from this layer, embracing change in the underlying software a core design principle.

hyper transforms software growth, from an expensive, painful, high-risk, all-in blind “gamble” into a cost-efficient, pleasant, architecture-focused, and informed “investment”.

### Team Domain Focus

By providing a simple and extensible API for the Cloud, the hyper Service Framework decouples business services from the Cloud services and infrastructure that power them.

Software teams are freed to focus on their core responsibilities, without blocking other teams, and without compromising on delivery.

Hyper organizations tame technical debt, using Clean Cloud Architecture, to sensibly scale their software and software teams, only when it’s needed, not all up-front.
